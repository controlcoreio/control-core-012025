"""
Vulnerability Management Service for Control Core
Implements SOC2-compliant vulnerability scanning and management
"""

import os
import json
import logging
import subprocess
import requests
from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict
from enum import Enum
import uuid
import asyncio
import aiohttp

logger = logging.getLogger(__name__)

class VulnerabilitySeverity(str, Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class VulnerabilityStatus(str, Enum):
    OPEN = "open"
    CONFIRMED = "confirmed"
    IN_PROGRESS = "in_progress"
    RESOLVED = "resolved"
    FALSE_POSITIVE = "false_positive"
    ACCEPTED_RISK = "accepted_risk"

class ScanType(str, Enum):
    DEPENDENCY = "dependency"
    CONTAINER = "container"
    NETWORK = "network"
    WEB_APPLICATION = "web_application"
    INFRASTRUCTURE = "infrastructure"
    CODE_ANALYSIS = "code_analysis"

class RemediationStatus(str, Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    NOT_APPLICABLE = "not_applicable"

@dataclass
class Vulnerability:
    vulnerability_id: str
    cve_id: Optional[str]
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: Optional[float]
    affected_component: str
    scan_type: ScanType
    detected_at: datetime
    last_scanned: datetime
    status: VulnerabilityStatus
    remediation_status: RemediationStatus
    remediation_notes: Optional[str]
    remediation_deadline: Optional[datetime]
    assigned_to: Optional[str]
    tags: List[str]
    references: List[str]
    exploit_available: bool
    public_exploit: bool
    created_at: datetime
    updated_at: datetime

@dataclass
class ScanResult:
    scan_id: str
    scan_type: ScanType
    target: str
    started_at: datetime
    completed_at: Optional[datetime]
    status: str
    vulnerabilities_found: int
    vulnerabilities: List[Vulnerability]
    scan_config: Dict[str, Any]
    scan_logs: List[str]

@dataclass
class RemediationPlan:
    plan_id: str
    vulnerability_id: str
    title: str
    description: str
    remediation_steps: List[str]
    estimated_effort_hours: int
    priority: int
    dependencies: List[str]
    resources_required: List[str]
    created_at: datetime
    updated_at: datetime

class VulnerabilityManagementService:
    """
    SOC2-compliant vulnerability management service
    Implements automated vulnerability scanning, assessment, and remediation tracking
    """
    
    def __init__(self):
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.scan_results: Dict[str, ScanResult] = {}
        self.remediation_plans: Dict[str, RemediationPlan] = {}
        
        # Configuration
        self.scanning_enabled = os.getenv('VULNERABILITY_SCANNING_ENABLED', 'true').lower() == 'true'
        self.auto_scanning_enabled = os.getenv('AUTO_VULNERABILITY_SCANNING', 'true').lower() == 'true'
        self.scan_interval_hours = int(os.getenv('VULNERABILITY_SCAN_INTERVAL_HOURS', '24'))
        self.audit_logging_enabled = os.getenv('VULNERABILITY_AUDIT_LOGGING', 'true').lower() == 'true'
        
        # External service configurations
        self.nvd_api_key = os.getenv('NVD_API_KEY', '')
        self.github_token = os.getenv('GITHUB_TOKEN', '')
        
        # Vulnerability databases
        self.vulnerability_databases = {
            'nvd': 'https://services.nvd.nist.gov/rest/json/cves/2.0',
            'github': 'https://api.github.com/advisories',
            'osv': 'https://api.osv.dev/v1/query'
        }
        
        # Severity thresholds
        self.severity_thresholds = {
            VulnerabilitySeverity.CRITICAL: 9.0,
            VulnerabilitySeverity.HIGH: 7.0,
            VulnerabilitySeverity.MEDIUM: 4.0,
            VulnerabilitySeverity.LOW: 0.1
        }
        
        # Remediation SLAs
        self.remediation_slas = {
            VulnerabilitySeverity.CRITICAL: 1,  # 1 day
            VulnerabilitySeverity.HIGH: 7,      # 7 days
            VulnerabilitySeverity.MEDIUM: 30,   # 30 days
            VulnerabilitySeverity.LOW: 90       # 90 days
        }
        
        logger.info("VulnerabilityManagementService initialized with SOC2 compliance")

    async def scan_dependencies(self, project_path: str, package_manager: str = "npm") -> ScanResult:
        """Scan project dependencies for vulnerabilities"""
        
        scan_id = str(uuid.uuid4())
        started_at = datetime.utcnow()
        
        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.DEPENDENCY,
            target=project_path,
            started_at=started_at,
            completed_at=None,
            status="running",
            vulnerabilities_found=0,
            vulnerabilities=[],
            scan_config={"package_manager": package_manager},
            scan_logs=[]
        )
        
        self.scan_results[scan_id] = scan_result
        
        try:
            if package_manager == "npm":
                vulnerabilities = await self._scan_npm_dependencies(project_path)
            elif package_manager == "pip":
                vulnerabilities = await self._scan_python_dependencies(project_path)
            elif package_manager == "go":
                vulnerabilities = await self._scan_go_dependencies(project_path)
            else:
                vulnerabilities = await self._scan_generic_dependencies(project_path, package_manager)
            
            scan_result.vulnerabilities = vulnerabilities
            scan_result.vulnerabilities_found = len(vulnerabilities)
            scan_result.status = "completed"
            scan_result.completed_at = datetime.utcnow()
            
            # Store vulnerabilities
            for vuln in vulnerabilities:
                self.vulnerabilities[vuln.vulnerability_id] = vuln
            
            # Log scan completion
            if self.audit_logging_enabled:
                self._log_scan_operation("dependency_scan", scan_id, len(vulnerabilities))
            
            logger.info(f"Dependency scan completed: {scan_id} - {len(vulnerabilities)} vulnerabilities found")
            
        except Exception as e:
            scan_result.status = "failed"
            scan_result.completed_at = datetime.utcnow()
            scan_result.scan_logs.append(f"Scan failed: {str(e)}")
            logger.error(f"Dependency scan failed: {scan_id} - {e}")
        
        return scan_result

    async def _scan_npm_dependencies(self, project_path: str) -> List[Vulnerability]:
        """Scan npm dependencies for vulnerabilities"""
        
        vulnerabilities = []
        
        try:
            # Run npm audit
            result = subprocess.run(
                ['npm', 'audit', '--json'],
                cwd=project_path,
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode == 0:
                audit_data = json.loads(result.stdout)
                
                for advisory in audit_data.get('vulnerabilities', {}).values():
                    vuln = Vulnerability(
                        vulnerability_id=str(uuid.uuid4()),
                        cve_id=advisory.get('cves', [None])[0] if advisory.get('cves') else None,
                        title=advisory.get('title', 'Unknown vulnerability'),
                        description=advisory.get('overview', 'No description available'),
                        severity=self._map_npm_severity(advisory.get('severity', 'moderate')),
                        cvss_score=self._extract_cvss_score(advisory),
                        affected_component=advisory.get('module_name', 'unknown'),
                        scan_type=ScanType.DEPENDENCY,
                        detected_at=datetime.utcnow(),
                        last_scanned=datetime.utcnow(),
                        status=VulnerabilityStatus.OPEN,
                        remediation_status=RemediationStatus.PENDING,
                        remediation_notes=None,
                        remediation_deadline=self._calculate_remediation_deadline(
                            self._map_npm_severity(advisory.get('severity', 'moderate'))
                        ),
                        assigned_to=None,
                        tags=[],
                        references=advisory.get('urls', []),
                        exploit_available=False,
                        public_exploit=False,
                        created_at=datetime.utcnow(),
                        updated_at=datetime.utcnow()
                    )
                    
                    vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Failed to scan npm dependencies: {e}")
        
        return vulnerabilities

    async def _scan_python_dependencies(self, project_path: str) -> List[Vulnerability]:
        """Scan Python dependencies for vulnerabilities"""
        
        vulnerabilities = []
        
        try:
            # Run safety check
            result = subprocess.run(
                ['safety', 'check', '--json'],
                cwd=project_path,
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode != 0:  # Safety returns non-zero for vulnerabilities found
                safety_data = json.loads(result.stdout)
                
                for vuln_data in safety_data:
                    vuln = Vulnerability(
                        vulnerability_id=str(uuid.uuid4()),
                        cve_id=vuln_data.get('cve'),
                        title=vuln_data.get('advisory', 'Unknown vulnerability'),
                        description=vuln_data.get('more_info_url', 'No description available'),
                        severity=VulnerabilitySeverity.HIGH,  # Safety doesn't provide severity
                        cvss_score=None,
                        affected_component=vuln_data.get('package'),
                        scan_type=ScanType.DEPENDENCY,
                        detected_at=datetime.utcnow(),
                        last_scanned=datetime.utcnow(),
                        status=VulnerabilityStatus.OPEN,
                        remediation_status=RemediationStatus.PENDING,
                        remediation_notes=None,
                        remediation_deadline=self._calculate_remediation_deadline(VulnerabilitySeverity.HIGH),
                        assigned_to=None,
                        tags=[],
                        references=[vuln_data.get('more_info_url', '')],
                        exploit_available=False,
                        public_exploit=False,
                        created_at=datetime.utcnow(),
                        updated_at=datetime.utcnow()
                    )
                    
                    vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Failed to scan Python dependencies: {e}")
        
        return vulnerabilities

    async def _scan_go_dependencies(self, project_path: str) -> List[Vulnerability]:
        """Scan Go dependencies for vulnerabilities"""
        
        vulnerabilities = []
        
        try:
            # Run govulncheck
            result = subprocess.run(
                ['govulncheck', './...'],
                cwd=project_path,
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode != 0:
                # Parse govulncheck output
                lines = result.stdout.split('\n')
                current_vuln = None
                
                for line in lines:
                    if line.startswith('Vulnerability:'):
                        if current_vuln:
                            vulnerabilities.append(current_vuln)
                        
                        current_vuln = Vulnerability(
                            vulnerability_id=str(uuid.uuid4()),
                            cve_id=None,
                            title=line.replace('Vulnerability:', '').strip(),
                            description='',
                            severity=VulnerabilitySeverity.MEDIUM,
                            cvss_score=None,
                            affected_component='',
                            scan_type=ScanType.DEPENDENCY,
                            detected_at=datetime.utcnow(),
                            last_scanned=datetime.utcnow(),
                            status=VulnerabilityStatus.OPEN,
                            remediation_status=RemediationStatus.PENDING,
                            remediation_notes=None,
                            remediation_deadline=self._calculate_remediation_deadline(VulnerabilitySeverity.MEDIUM),
                            assigned_to=None,
                            tags=[],
                            references=[],
                            exploit_available=False,
                            public_exploit=False,
                            created_at=datetime.utcnow(),
                            updated_at=datetime.utcnow()
                        )
                    elif current_vuln and line.startswith('  '):
                        current_vuln.description += line.strip() + ' '
                
                if current_vuln:
                    vulnerabilities.append(current_vuln)
        
        except Exception as e:
            logger.error(f"Failed to scan Go dependencies: {e}")
        
        return vulnerabilities

    async def _scan_generic_dependencies(self, project_path: str, package_manager: str) -> List[Vulnerability]:
        """Generic dependency scanning for other package managers"""
        
        # This would be implemented for other package managers like Maven, Gradle, etc.
        logger.info(f"Generic dependency scanning not implemented for {package_manager}")
        return []

    async def scan_container_image(self, image_name: str) -> ScanResult:
        """Scan container image for vulnerabilities"""
        
        scan_id = str(uuid.uuid4())
        started_at = datetime.utcnow()
        
        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.CONTAINER,
            target=image_name,
            started_at=started_at,
            completed_at=None,
            status="running",
            vulnerabilities_found=0,
            vulnerabilities=[],
            scan_config={"image": image_name},
            scan_logs=[]
        )
        
        self.scan_results[scan_id] = scan_result
        
        try:
            # Use Trivy for container scanning
            vulnerabilities = await self._scan_with_trivy(image_name)
            
            scan_result.vulnerabilities = vulnerabilities
            scan_result.vulnerabilities_found = len(vulnerabilities)
            scan_result.status = "completed"
            scan_result.completed_at = datetime.utcnow()
            
            # Store vulnerabilities
            for vuln in vulnerabilities:
                self.vulnerabilities[vuln.vulnerability_id] = vuln
            
            logger.info(f"Container scan completed: {scan_id} - {len(vulnerabilities)} vulnerabilities found")
            
        except Exception as e:
            scan_result.status = "failed"
            scan_result.completed_at = datetime.utcnow()
            scan_result.scan_logs.append(f"Scan failed: {str(e)}")
            logger.error(f"Container scan failed: {scan_id} - {e}")
        
        return scan_result

    async def _scan_with_trivy(self, image_name: str) -> List[Vulnerability]:
        """Scan container image using Trivy"""
        
        vulnerabilities = []
        
        try:
            # Run Trivy scan
            result = subprocess.run(
                ['trivy', 'image', '--format', 'json', image_name],
                capture_output=True,
                text=True,
                timeout=600
            )
            
            if result.returncode == 0:
                trivy_data = json.loads(result.stdout)
                
                for result_data in trivy_data.get('Results', []):
                    for vuln_data in result_data.get('Vulnerabilities', []):
                        vuln = Vulnerability(
                            vulnerability_id=str(uuid.uuid4()),
                            cve_id=vuln_data.get('VulnerabilityID'),
                            title=vuln_data.get('Title', 'Unknown vulnerability'),
                            description=vuln_data.get('Description', 'No description available'),
                            severity=self._map_trivy_severity(vuln_data.get('Severity', 'UNKNOWN')),
                            cvss_score=vuln_data.get('CVSS', {}).get('nvd', {}).get('V3Score'),
                            affected_component=vuln_data.get('PkgName', 'unknown'),
                            scan_type=ScanType.CONTAINER,
                            detected_at=datetime.utcnow(),
                            last_scanned=datetime.utcnow(),
                            status=VulnerabilityStatus.OPEN,
                            remediation_status=RemediationStatus.PENDING,
                            remediation_notes=None,
                            remediation_deadline=self._calculate_remediation_deadline(
                                self._map_trivy_severity(vuln_data.get('Severity', 'UNKNOWN'))
                            ),
                            assigned_to=None,
                            tags=[],
                            references=vuln_data.get('References', []),
                            exploit_available=False,
                            public_exploit=False,
                            created_at=datetime.utcnow(),
                            updated_at=datetime.utcnow()
                        )
                        
                        vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Failed to scan with Trivy: {e}")
        
        return vulnerabilities

    async def scan_web_application(self, target_url: str) -> ScanResult:
        """Scan web application for vulnerabilities"""
        
        scan_id = str(uuid.uuid4())
        started_at = datetime.utcnow()
        
        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type=ScanType.WEB_APPLICATION,
            target=target_url,
            started_at=started_at,
            completed_at=None,
            status="running",
            vulnerabilities_found=0,
            vulnerabilities=[],
            scan_config={"target": target_url},
            scan_logs=[]
        )
        
        self.scan_results[scan_id] = scan_result
        
        try:
            # Basic web application security checks
            vulnerabilities = await self._perform_web_security_checks(target_url)
            
            scan_result.vulnerabilities = vulnerabilities
            scan_result.vulnerabilities_found = len(vulnerabilities)
            scan_result.status = "completed"
            scan_result.completed_at = datetime.utcnow()
            
            # Store vulnerabilities
            for vuln in vulnerabilities:
                self.vulnerabilities[vuln.vulnerability_id] = vuln
            
            logger.info(f"Web application scan completed: {scan_id} - {len(vulnerabilities)} vulnerabilities found")
            
        except Exception as e:
            scan_result.status = "failed"
            scan_result.completed_at = datetime.utcnow()
            scan_result.scan_logs.append(f"Scan failed: {str(e)}")
            logger.error(f"Web application scan failed: {scan_id} - {e}")
        
        return scan_result

    async def _perform_web_security_checks(self, target_url: str) -> List[Vulnerability]:
        """Perform basic web security checks"""
        
        vulnerabilities = []
        
        try:
            async with aiohttp.ClientSession() as session:
                # Check for security headers
                async with session.get(target_url) as response:
                    headers = response.headers
                    
                    # Check for missing security headers
                    security_headers = {
                        'Strict-Transport-Security': 'Missing HSTS header',
                        'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                        'X-Frame-Options': 'Missing X-Frame-Options header',
                        'X-XSS-Protection': 'Missing X-XSS-Protection header'
                    }
                    
                    for header, description in security_headers.items():
                        if header not in headers:
                            vuln = Vulnerability(
                                vulnerability_id=str(uuid.uuid4()),
                                cve_id=None,
                                title=f"Missing {header}",
                                description=description,
                                severity=VulnerabilitySeverity.MEDIUM,
                                cvss_score=None,
                                affected_component=target_url,
                                scan_type=ScanType.WEB_APPLICATION,
                                detected_at=datetime.utcnow(),
                                last_scanned=datetime.utcnow(),
                                status=VulnerabilityStatus.OPEN,
                                remediation_status=RemediationStatus.PENDING,
                                remediation_notes=None,
                                remediation_deadline=self._calculate_remediation_deadline(VulnerabilitySeverity.MEDIUM),
                                assigned_to=None,
                                tags=['security-headers'],
                                references=[],
                                exploit_available=False,
                                public_exploit=False,
                                created_at=datetime.utcnow(),
                                updated_at=datetime.utcnow()
                            )
                            
                            vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Failed to perform web security checks: {e}")
        
        return vulnerabilities

    def _map_npm_severity(self, npm_severity: str) -> VulnerabilitySeverity:
        """Map npm severity to internal severity"""
        
        mapping = {
            'critical': VulnerabilitySeverity.CRITICAL,
            'high': VulnerabilitySeverity.HIGH,
            'moderate': VulnerabilitySeverity.MEDIUM,
            'low': VulnerabilitySeverity.LOW,
            'info': VulnerabilitySeverity.INFO
        }
        
        return mapping.get(npm_severity, VulnerabilitySeverity.MEDIUM)

    def _map_trivy_severity(self, trivy_severity: str) -> VulnerabilitySeverity:
        """Map Trivy severity to internal severity"""
        
        mapping = {
            'CRITICAL': VulnerabilitySeverity.CRITICAL,
            'HIGH': VulnerabilitySeverity.HIGH,
            'MEDIUM': VulnerabilitySeverity.MEDIUM,
            'LOW': VulnerabilitySeverity.LOW,
            'UNKNOWN': VulnerabilitySeverity.INFO
        }
        
        return mapping.get(trivy_severity, VulnerabilitySeverity.MEDIUM)

    def _extract_cvss_score(self, advisory_data: Dict[str, Any]) -> Optional[float]:
        """Extract CVSS score from advisory data"""
        
        # This would extract CVSS score from various sources
        # For now, return None as npm audit doesn't always provide CVSS scores
        return None

    def _calculate_remediation_deadline(self, severity: VulnerabilitySeverity) -> datetime:
        """Calculate remediation deadline based on severity"""
        
        sla_days = self.remediation_slas.get(severity, 90)
        return datetime.utcnow() + timedelta(days=sla_days)

    def create_remediation_plan(self, vulnerability_id: str, plan_data: Dict[str, Any]) -> RemediationPlan:
        """Create a remediation plan for a vulnerability"""
        
        if vulnerability_id not in self.vulnerabilities:
            logger.error(f"Vulnerability not found: {vulnerability_id}")
            return None
        
        plan_id = str(uuid.uuid4())
        current_time = datetime.utcnow()
        
        plan = RemediationPlan(
            plan_id=plan_id,
            vulnerability_id=vulnerability_id,
            title=plan_data.get('title', 'Remediation Plan'),
            description=plan_data.get('description', ''),
            remediation_steps=plan_data.get('steps', []),
            estimated_effort_hours=plan_data.get('effort_hours', 1),
            priority=plan_data.get('priority', 1),
            dependencies=plan_data.get('dependencies', []),
            resources_required=plan_data.get('resources', []),
            created_at=current_time,
            updated_at=current_time
        )
        
        self.remediation_plans[plan_id] = plan
        
        # Update vulnerability status
        vulnerability = self.vulnerabilities[vulnerability_id]
        vulnerability.remediation_status = RemediationStatus.IN_PROGRESS
        vulnerability.updated_at = current_time
        
        logger.info(f"Remediation plan created: {plan_id} for vulnerability {vulnerability_id}")
        return plan

    def update_vulnerability_status(
        self,
        vulnerability_id: str,
        status: VulnerabilityStatus,
        remediation_status: Optional[RemediationStatus] = None,
        notes: Optional[str] = None,
        assigned_to: Optional[str] = None
    ):
        """Update vulnerability status"""
        
        if vulnerability_id not in self.vulnerabilities:
            logger.error(f"Vulnerability not found: {vulnerability_id}")
            return
        
        vulnerability = self.vulnerabilities[vulnerability_id]
        vulnerability.status = status
        
        if remediation_status:
            vulnerability.remediation_status = remediation_status
        
        if notes:
            vulnerability.remediation_notes = notes
        
        if assigned_to:
            vulnerability.assigned_to = assigned_to
        
        vulnerability.updated_at = datetime.utcnow()
        
        logger.info(f"Vulnerability {vulnerability_id} status updated to {status.value}")

    def get_vulnerabilities_by_severity(self, severity: VulnerabilitySeverity) -> List[Vulnerability]:
        """Get vulnerabilities by severity"""
        
        return [vuln for vuln in self.vulnerabilities.values() if vuln.severity == severity]

    def get_vulnerabilities_by_status(self, status: VulnerabilityStatus) -> List[Vulnerability]:
        """Get vulnerabilities by status"""
        
        return [vuln for vuln in self.vulnerabilities.values() if vuln.status == status]

    def get_vulnerabilities_summary(self) -> Dict[str, Any]:
        """Get vulnerability management summary"""
        
        total_vulnerabilities = len(self.vulnerabilities)
        
        summary = {
            "total_vulnerabilities": total_vulnerabilities,
            "by_severity": {},
            "by_status": {},
            "by_scan_type": {},
            "open_vulnerabilities": 0,
            "overdue_vulnerabilities": 0,
            "remediation_plans": len(self.remediation_plans),
            "scan_results": len(self.scan_results)
        }
        
        current_time = datetime.utcnow()
        
        for vuln in self.vulnerabilities.values():
            # Count by severity
            severity = vuln.severity.value
            summary["by_severity"][severity] = summary["by_severity"].get(severity, 0) + 1
            
            # Count by status
            status = vuln.status.value
            summary["by_status"][status] = summary["by_status"].get(status, 0) + 1
            
            # Count by scan type
            scan_type = vuln.scan_type.value
            summary["by_scan_type"][scan_type] = summary["by_scan_type"].get(scan_type, 0) + 1
            
            # Count open vulnerabilities
            if vuln.status in [VulnerabilityStatus.OPEN, VulnerabilityStatus.CONFIRMED]:
                summary["open_vulnerabilities"] += 1
            
            # Count overdue vulnerabilities
            if (vuln.remediation_deadline and 
                vuln.remediation_deadline < current_time and 
                vuln.status not in [VulnerabilityStatus.RESOLVED, VulnerabilityStatus.FALSE_POSITIVE]):
                summary["overdue_vulnerabilities"] += 1
        
        return summary

    def _log_scan_operation(self, operation: str, scan_id: str, vulnerabilities_found: int):
        """Log scan operations for SOC2 audit trail"""
        
        audit_log = {
            "timestamp": datetime.utcnow().isoformat(),
            "operation": operation,
            "scan_id": scan_id,
            "vulnerabilities_found": vulnerabilities_found,
            "service": "vulnerability_management_service"
        }
        
        logger.info(f"VULNERABILITY_SCAN_AUDIT: {json.dumps(audit_log)}")

# Global vulnerability management service instance
vulnerability_management_service = VulnerabilityManagementService()
