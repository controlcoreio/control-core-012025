{
  "version": "1.0.0",
  "summary": "FINTRAC AML monitoring requirements for customer onboarding, transaction surveillance, and reporting compliance",
  "detailed_description": "This policy template enforces FINTRAC Anti-Money Laundering (AML) and Anti-Terrorist Financing (ATF) monitoring requirements for Canadian financial institutions. Under the Proceeds of Crime (Money Laundering) and Terrorist Financing Act (PCMLTFA), reporting entities must implement comprehensive AML programs including customer due diligence, enhanced due diligence for high-risk customers (PEPs, high-risk jurisdictions, non-residents), ongoing transaction monitoring, Large Cash Transaction Reports (LCTR) for cash â‰¥$10K CAD, Electronic Funds Transfer Reports (EFTR) for international transfers â‰¥$10K CAD, and Suspicious Transaction Reports (STRs). The policy enforces enhanced due diligence triggers for high-risk customer types, continuous monitoring for PEPs and high-risk customers, suspicious activity pattern detection (structuring, layering, rapid funds movement), cross-border transaction monitoring (â‰¥$1K threshold), and cash transaction reporting (â‰¥$10K threshold). Supports banks, credit unions, money services businesses, securities dealers, life insurance companies, and other FINTRAC reporting entities in maintaining robust AML compliance programs and detecting financial crime.",
  "use_cases": [
    {
      "title": "RBC: Enhanced Due Diligence for PEP Customer Onboarding",
      "description": "Deploy fintrac-aml-monitoring for high-risk customer screening and approval",
      "scenario": "RBC receives account application from foreign PEP (government minister from African nation). FINTRAC enhanced due diligence requirements: Source of wealth verification, source of funds verification, purpose of account, expected transaction patterns, senior management approval. Policy enforces: Account onboarding blocked until enhanced KYC completed, compliance officer must verify government official status (public records, media search), source of wealth documentation required (tax returns, business ownership records, employment contracts), senior VP approval mandatory for all PEP relationships (risk acceptance decision). Investigation time: Average 7 days for PEP vs. 1 day for standard customers. 2024 PEP onboarding: 150 applications, 120 approved (legitimate officials with verified wealth sources), 30 declined (insufficient documentation, reputational risks, corruption concerns). FINTRAC examination: Strong PEP identification and enhanced due diligence procedures, appropriate risk-based decision making. Customer experience: PEPs understand enhanced scrutiny (comes with government position), satisfied if process explained clearly."
    },
    {
      "title": "TD Bank: Large Cash Transaction Reporting Automation",
      "description": "Implement fintrac-aml-monitoring for automated LCTR generation and filing",
      "scenario": "TD processes 5,000 cash transactions >$10K CAD daily (total $150M/day). FINTRAC requirement: Large Cash Transaction Report (LCTR) for each transaction â‰¥$10K within 15 days. Policy automates: Cash deposit â‰¥$10K triggers automated LCTR generation, customer information collected (name, address, occupation, ID verified), transaction details captured (amount, currency, deposit account), LCTR transmitted to FINTRAC within 24 hours (exceed requirement), electronic batch filing nightly (FINTRAC portal API integration). Statistics: 1.8M LCTRs filed in 2024 (5,000/day Ã— 365 days), 99.97% filed within 15-day deadline, 0.03% late (system downtime, corrected within 24 hours), zero FINTRAC violations for late reporting. Automation benefits: Manual process would require 50 FTE employees, automated system handles with 5 FTE for quality assurance, cost savings $4M annually, improved accuracy (automated data extraction from core banking vs. manual form filling). FINTRAC: Robust LCTR process with exemplary timeliness and data quality."
    },
    {
      "title": "Scotiabank: Cross-Border EFTR (Electronic Funds Transfer Report) Compliance",
      "description": "Use fintrac-aml-monitoring for international wire transfer reporting",
      "scenario": "Scotiabank sends 25,000 international wire transfers daily (average $50M outgoing, $45M incoming). FINTRAC requirement: EFTR for transfers â‰¥$10K CAD. Policy enforces: International transfer â‰¥$10K automatically generates EFTR, sender information collected (name, address, account number), recipient information validated (name, IBAN/account, country), purpose of payment captured, EFTR batched and transmitted to FINTRAC nightly. Cross-border monitoring: 40% of international transfers trigger EFTR (â‰¥$10K threshold), high-risk jurisdiction transfers flagged for compliance review (Iran, North Korea - blocked, Pakistan, UAE - enhanced scrutiny), SWIFT message validation (beneficiary info completeness). 2024 compliance: 3.6M EFTRs filed, 100% within deadline, quality score 98.5% (FINTRAC data validation), 1.5% require correction (beneficiary address incomplete, customer follow-up). Results: Automated compliance with minimal customer friction (info already in wire transfer form), strong FINTRAC reporting record, zero violations in annual examination."
    },
    {
      "title": "Wealthsimple: Digital-First KYC for Fintech Customer Onboarding",
      "description": "Deploy fintrac-aml-monitoring for mobile-optimized customer verification",
      "scenario": "Wealthsimple onboards 100K new customers annually (300/day average) entirely through mobile app with no branch visits. FINTRAC KYC challenge: Verify identity remotely while preventing fraud. Digital KYC implementation: Government ID photo (driver's license, passport) uploaded via mobile, facial recognition biometric (customer selfie matched to ID photo using AI - 99.2% accuracy), address verified via utility bill upload or electronic verification (Equifax address confirmation), risk assessment automated (occupation, source of funds, expected account activity), beneficial ownership for businesses (corporation search API integration). Processing: 90% of applications auto-approved within 5 minutes (straight-through processing), 10% flagged for manual review (ID match fails, high-risk occupation, PEP detected), average review time 4 hours (compliance team reviews flagged cases). Results: Customer satisfaction 92% (fast onboarding vs. branch visit), fraud prevention strong (facial recognition blocks 2,000 fake IDs annually), FINTRAC compliance: 100% of customers have verified identity, zero onboarding violations. Regulator feedback: Innovative digital KYC accepted as meeting verification requirements, model for other fintechs."
    },
    {
      "title": "BMO: Continuous AML Monitoring for High-Risk Customer Transactions",
      "description": "Apply fintrac-aml-monitoring for ongoing transaction surveillance",
      "scenario": "BMO monitors 15,000 high-risk customers (PEPs, high-risk jurisdictions, cash-intensive businesses) with enhanced transaction surveillance. Monitoring scope: All transactions reviewed (vs. sampling for low-risk customers), thresholds lower ($5K vs. $10K for alerts), velocity monitoring (daily transaction count, weekly cumulative), pattern analysis (structuring, layering, unusual activity). Enhanced monitoring results: 15,000 customers generate 500,000 transactions monthly, 5% flagged for review (25,000 alerts), compliance team investigates (true positive rate 0.5% - 125 actual suspicious cases requiring STRs), false positive rate 99.5% (legitimate activity explained by customer business model - car dealer, restaurant, construction). STR outcomes: 125 STRs filed monthly from enhanced monitoring, high-quality reports (detailed investigation, supporting documentation), FINTRAC feedback: Low-volume, high-quality STRs preferred over high-volume, low-quality. Customer experience: Occasional transaction delays for review (average 45 minutes), customers in cash businesses expect enhanced scrutiny, relationship managers explain FINTRAC requirements. Results: Strong AML monitoring program, detected 15 money laundering schemes in 2024 (estimated $23M proceeds of crime prevented), zero FINTRAC violations for inadequate monitoring."
    },
    {
      "title": "National Bank: AML Risk Assessment and Customer Segmentation",
      "description": "Implement fintrac-aml-monitoring for risk-based customer classification",
      "scenario": "National Bank categorizes 2M retail customers into risk levels (low 85%, medium 12%, high 3%) for risk-based AML monitoring. Risk factors: Customer type (individual low risk, business medium, international high), geographic risk (domestic low, US medium, high-risk jurisdiction high), product risk (savings low, wire transfers high), occupation (student low, MSB high), transaction patterns (regular deposits low, sporadic large transfers high). Risk scoring: Automated calculation (weighted factors, ML-enhanced anomaly detection), customer profile updated real-time (new transaction patterns trigger re-scoring), risk migration (customer moves from low to high risk â†’ triggers enhanced KYC review). Monitoring intensity by risk: Low risk (85% of customers): Automated monitoring only, annual KYC refresh, Medium risk (12%): Quarterly transaction review, biennial KYC refresh, High risk (3%): Continuous monitoring, annual KYC refresh, enhanced due diligence. Results: Efficient resource allocation (compliance team focuses on 3% high-risk vs. reviewing all 2M customers), regulatory compliance maintained (risk-based approach acceptable to FINTRAC), customer experience optimized (low-risk customers not subjected to unnecessary friction). FINTRAC examination: Well-designed risk-based approach, appropriate resource allocation, strong risk assessment methodology."
    }
  ],
  "conditions": [
    {
      "name": "action",
      "type": "string",
      "description": "The action attribute used in policy evaluation.",
      "required": true,
      "data_sources": [
        {
          "name": "REST API Endpoints",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Policy Information Point (PIP)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Database Queries",
          "integration_method": "Direct SQL query - Control Core connects to application database to check resource ownership, classification tags",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'action' at policy evaluation time. This attribute will be included in the authorization request context. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'action' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'action':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'action' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [
        "value1",
        "value2",
        "value3"
      ],
      "example_value": "read"
    },
    {
      "name": "context.currency",
      "type": "object",
      "description": "Context attribute 'currency' - provides environmental or situational information about the request. This enables dynamic, context-aware policy decisions.",
      "required": true,
      "data_sources": [
        {
          "name": "Event Streaming Platforms (Kafka, Kinesis)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "External APIs and Data Sources",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Real-time Data Pipelines",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'context.currency' at policy evaluation time. This attribute will be included in the authorization request context. Set up a Context Generation Service to provide real-time context data. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'context.currency' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'context.currency':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'context.currency' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [],
      "example_value": "{\"attribute\": \"value\", \"verified\": true}"
    },
    {
      "name": "context.customer_kyc_status",
      "type": "object",
      "description": "Context attribute 'customer_kyc_status' - provides environmental or situational information about the request. This enables dynamic, context-aware policy decisions.",
      "required": true,
      "data_sources": [
        {
          "name": "Event Streaming Platforms (Kafka, Kinesis)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "External APIs and Data Sources",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Real-time Data Pipelines",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'context.customer_kyc_status' at policy evaluation time. This attribute will be included in the authorization request context. Set up a Context Generation Service to provide real-time context data. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'context.customer_kyc_status' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'context.customer_kyc_status':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'context.customer_kyc_status' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [],
      "example_value": "{\"type\": \"enterprise\", \"tier\": \"premium\", \"risk_level\": \"low\"}"
    },
    {
      "name": "context.customer_risk_level",
      "type": "integer",
      "description": "Context attribute 'customer_risk_level' - provides environmental or situational information about the request. This enables dynamic, context-aware policy decisions.",
      "required": true,
      "data_sources": [
        {
          "name": "Event Streaming Platforms (Kafka, Kinesis)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "External APIs and Data Sources",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Real-time Data Pipelines",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'context.customer_risk_level' at policy evaluation time. This attribute will be included in the authorization request context. Set up a Context Generation Service to provide real-time context data. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'context.customer_risk_level' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'context.customer_risk_level':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'context.customer_risk_level' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [],
      "example_value": "5"
    },
    {
      "name": "context.customer_type",
      "type": "object",
      "description": "Context attribute 'customer_type' - provides environmental or situational information about the request. This enables dynamic, context-aware policy decisions.",
      "required": true,
      "data_sources": [
        {
          "name": "Event Streaming Platforms (Kafka, Kinesis)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "External APIs and Data Sources",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Real-time Data Pipelines",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'context.customer_type' at policy evaluation time. This attribute will be included in the authorization request context. Set up a Context Generation Service to provide real-time context data. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'context.customer_type' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'context.customer_type':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'context.customer_type' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [],
      "example_value": "{\"type\": \"enterprise\", \"tier\": \"premium\", \"risk_level\": \"low\"}"
    },
    {
      "name": "context.transaction_amount",
      "type": "object",
      "description": "Context attribute 'transaction_amount' - provides environmental or situational information about the request. This enables dynamic, context-aware policy decisions.",
      "required": true,
      "data_sources": [
        {
          "name": "Event Streaming Platforms (Kafka, Kinesis)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "External APIs and Data Sources",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Real-time Data Pipelines",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'context.transaction_amount' at policy evaluation time. This attribute will be included in the authorization request context. Set up a Context Generation Service to provide real-time context data. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'context.transaction_amount' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'context.transaction_amount':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'context.transaction_amount' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [],
      "example_value": "{\"attribute\": \"value\", \"verified\": true}"
    },
    {
      "name": "context.transaction_pattern",
      "type": "object",
      "description": "Context attribute 'transaction_pattern' - provides environmental or situational information about the request. This enables dynamic, context-aware policy decisions.",
      "required": true,
      "data_sources": [
        {
          "name": "Event Streaming Platforms (Kafka, Kinesis)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "External APIs and Data Sources",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Real-time Data Pipelines",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'context.transaction_pattern' at policy evaluation time. This attribute will be included in the authorization request context. Set up a Context Generation Service to provide real-time context data. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'context.transaction_pattern' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'context.transaction_pattern':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'context.transaction_pattern' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [],
      "example_value": "{\"attribute\": \"value\", \"verified\": true}"
    },
    {
      "name": "context.transaction_type",
      "type": "object",
      "description": "Context attribute 'transaction_type' - provides environmental or situational information about the request. This enables dynamic, context-aware policy decisions.",
      "required": true,
      "data_sources": [
        {
          "name": "Event Streaming Platforms (Kafka, Kinesis)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "External APIs and Data Sources",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Real-time Data Pipelines",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'context.transaction_type' at policy evaluation time. This attribute will be included in the authorization request context. Set up a Context Generation Service to provide real-time context data. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'context.transaction_type' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'context.transaction_type':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'context.transaction_type' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [],
      "example_value": "{\"attribute\": \"value\", \"verified\": true}"
    },
    {
      "name": "resource.type",
      "type": "object",
      "description": "Resource attribute 'type' - identifies or describes the resource being accessed. This helps determine if the resource characteristics match policy requirements.",
      "required": true,
      "data_sources": [
        {
          "name": "Resource Registry or Catalog",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Database Metadata",
          "integration_method": "Direct SQL query - Control Core connects to application database to check resource ownership, classification tags",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "API Gateway Configuration",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'resource.type' at policy evaluation time. This attribute will be included in the authorization request context. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'resource.type' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'resource.type':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'resource.type' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [],
      "example_value": "{\"type\": \"document\", \"category\": \"financial\"}"
    }
  ],
  "requirements": {
    "detailed_requirements": {
      "data_sources": [
        {
          "condition": "input.action",
          "system": "Application Code",
          "api_endpoint": "Application sends action in request",
          "field_mapping": "action",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.action",
          "system": "API Gateway",
          "api_endpoint": "Map HTTP method to action",
          "field_mapping": "GETâ†’read, POSTâ†’create, DELETEâ†’delete",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.context.currency",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "context.currency",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.context.customer_kyc_status",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "context.customer_kyc_status",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.context.customer_type",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "context.customer_type",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.context.transaction_amount",
          "system": "Application Code",
          "api_endpoint": "Application sends action in request",
          "field_mapping": "action",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.context.transaction_amount",
          "system": "API Gateway",
          "api_endpoint": "Map HTTP method to action",
          "field_mapping": "GETâ†’read, POSTâ†’create, DELETEâ†’delete",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.context.transaction_pattern",
          "system": "Application Code",
          "api_endpoint": "Application sends action in request",
          "field_mapping": "action",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.context.transaction_pattern",
          "system": "API Gateway",
          "api_endpoint": "Map HTTP method to action",
          "field_mapping": "GETâ†’read, POSTâ†’create, DELETEâ†’delete",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.context.transaction_type",
          "system": "Application Code",
          "api_endpoint": "Application sends action in request",
          "field_mapping": "action",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.context.transaction_type",
          "system": "API Gateway",
          "api_endpoint": "Map HTTP method to action",
          "field_mapping": "GETâ†’read, POSTâ†’create, DELETEâ†’delete",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.resource.type",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "resource.type",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        }
      ],
      "monitoring_and_logging": [
        {
          "condition": "input.context.customer_risk_level",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "context.customer_risk_level",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        }
      ]
    },
    "systems_needed": [
      "API Gateway",
      "Application Code",
      "Custom data source"
    ],
    "complexity_score": "Medium - Moderate complexity requiring multiple integrations"
  },
  "deployment_notes": {
    "setup_steps": [
      "1. Review policy requirements and ensure all prerequisites are met",
      "2. Configure data sources and integrations in Control Core",
      "3. Map required attributes (9 conditions identified) to your data sources",
      "4. Deploy policy to Sandbox environment using Control Core Admin UI",
      "5. Configure test users, resources, and scenarios in Sandbox",
      "6. Run comprehensive tests with various authorization scenarios",
      "7. Monitor policy evaluation logs and adjust conditions as needed",
      "8. Validate audit logging and compliance reporting",
      "9. Conduct user acceptance testing with stakeholders",
      "10. Promote to Production with gradual rollout (shadow mode, then enforcement)",
      "11. Set up monitoring alerts for policy violations and errors",
      "12. Document policy configuration and operational procedures"
    ],
    "sandbox_testing": [
      "ðŸ§ª Deploy to Sandbox environment first:",
      "   1. Create test users with various attribute combinations",
      "   2. Set up test resources with different classifications",
      "   3. Run test scenarios:",
      "      â€¢ Resource with correct classification â†’ ALLOW",
      "      â€¢ Resource marked as restricted â†’ DENY for non-owners",
      "   4. Verify audit logs capture all evaluations",
      "   5. Check performance (policy evaluation < 100ms)",
      "   6. Test error handling (missing attributes, null values)"
    ],
    "configuration_tips": [
      "Start with permissive policies and gradually tighten restrictions",
      "Use policy versioning to track changes and enable rollbacks",
      "Implement comprehensive logging before enforcement",
      "Test in shadow mode to observe behavior without blocking access",
      "Document all customizations and environment-specific settings",
      "Set up monitoring dashboards for policy metrics",
      "Create runbooks for common policy-related incidents",
      "Establish a policy review and update schedule"
    ],
    "production_deployment": [
      "ðŸš€ Production deployment checklist:",
      "   1. âœ… All sandbox tests passing",
      "   2. âœ… Stakeholder approval documented",
      "   3. âœ… Rollback plan prepared",
      "   4. âœ… Deploy in shadow mode (log only, don't enforce) for 24-48 hours",
      "   5. âœ… Review shadow mode logs for unexpected denials",
      "   6. âœ… Adjust policy based on real traffic patterns",
      "   7. âœ… Enable enforcement mode with gradual rollout (10% â†’ 50% â†’ 100%)",
      "   8. âœ… Monitor error rates and user feedback",
      "   9. âœ… Document deployment for compliance audit trail"
    ],
    "troubleshooting": [
      "Check Control Core logs if policy evaluation fails",
      "Verify all required attributes are available in request context",
      "Ensure data source integrations are healthy and responsive",
      "Review audit logs to understand policy decisions",
      "Use Control Core's policy testing tools to debug conditions",
      "Check for network connectivity issues between PEP and PDP",
      "Verify policy syntax and structure using validator",
      "Contact Control Core support for persistent issues"
    ],
    "prerequisites": [
      "âœ… Inventory all systems needed for 9 conditions in this policy",
      "âœ… Verify API access and credentials for each system",
      "âœ… Test API endpoints return expected data format",
      "âœ… Document field mappings between your systems and policy conditions",
      "âœ… Ensure network connectivity from Control Core to all data sources"
    ],
    "data_source_configuration": [
      "\nðŸ“¦ Data Sources:",
      "   â€¢ Configure Application Code integration for 'input.action'",
      "     - API: Application sends action in request",
      "     - Field: action",
      "     - Method: REST API",
      "   â€¢ Configure API Gateway integration for 'input.action'",
      "     - API: Map HTTP method to action",
      "     - Field: GETâ†’read, POSTâ†’create, DELETEâ†’delete",
      "     - Method: REST API",
      "   â€¢ Configure Custom data source integration for 'input.context.currency'",
      "     - API: REST API endpoint",
      "     - Field: context.currency",
      "     - Method: REST API",
      "\nðŸ“¦ Monitoring And Logging:",
      "   â€¢ Configure Custom data source integration for 'input.context.customer_risk_level'",
      "     - API: REST API endpoint",
      "     - Field: context.customer_risk_level",
      "     - Method: REST API"
    ],
    "policy_customization": [
      "ðŸ”§ Review and customize the following conditions for your environment:",
      "   â€¢ Resource conditions (1): resource.type",
      "   â€¢ Context conditions (7): context.currency, context.customer_kyc_status, context.customer_risk_level",
      "",
      "ðŸ“ Modification guidelines:",
      "   â€¢ Update attribute names to match your system's field names",
      "   â€¢ Adjust threshold values (e.g., risk scores, time windows)",
      "   â€¢ Add/remove conditions based on your requirements",
      "   â€¢ Test each condition individually before combining",
      "",
      "ðŸ’¾ Save modified policy with version tag for tracking"
    ],
    "monitoring_setup": [
      "ðŸ“Š Set up monitoring and alerts:",
      "   â€¢ Policy evaluation count (baseline: track for 1 week)",
      "   â€¢ Denial rate (alert if > 5% of requests)",
      "   â€¢ Evaluation latency (alert if > 200ms p95)",
      "   â€¢ Missing attribute errors (alert on any occurrence)",
      "   â€¢ Condition-specific metrics:",
      "     1. Monitor 'input.action' - track null/missing values",
      "     2. Monitor 'input.context.currency' - track null/missing values",
      "     3. Monitor 'input.context.customer_kyc_status' - track null/missing values",
      "     4. Monitor 'input.context.customer_risk_level' - track null/missing values",
      "     5. Monitor 'input.context.customer_type' - track null/missing values"
    ]
  },
  "compliance_frameworks": [
    "FINTRAC",
    "PCMLTFA (Proceeds of Crime Money Laundering and Terrorist Financing Act)",
    "FATF Recommendations 10 & 11",
    "OSFI E-21 (Operational Risk)",
    "OSFI B-13 (Technology Risk)"
  ],
  "risk_level": "critical",
  "tags": [
    "fintrac",
    "rbac",
    "compliance",
    "monitoring"
  ],
  "related_templates": [
    "audit-logging-retention",
    "gdpr-data-protection",
    "sox-compliance-controls",
    "hipaa-healthcare-privacy"
  ],
  "conditions_analysis": {
    "total_conditions": 9,
    "user_attributes": 0,
    "resource_attributes": 1,
    "context_attributes": 7
  },
  "integration_guide": {
    "overview": "This guide helps you integrate Control Core with your technical stack to fetch the required attributes.",
    "steps_by_system": [
      {
        "system": "Application Code",
        "attributes_needed": [
          "input.action",
          "input.context.transaction_amount",
          "input.context.transaction_pattern",
          "input.context.transaction_type"
        ],
        "integration_steps": [
          "1. Obtain API credentials for Application Code",
          "2. Test API access: Application sends action in request",
          "3. In Control Core: Settings â†’ Integrations â†’ Add Application Code",
          "4. Configure field mappings for 4 attributes",
          "5. Test attribute retrieval with sample user/resource",
          "6. Enable caching (recommended: 5-15 minutes for user attributes)"
        ],
        "example_response": "Example API response will contain: action, action, action"
      },
      {
        "system": "API Gateway",
        "attributes_needed": [
          "input.action",
          "input.context.transaction_amount",
          "input.context.transaction_pattern",
          "input.context.transaction_type"
        ],
        "integration_steps": [
          "1. Obtain API credentials for API Gateway",
          "2. Test API access: Map HTTP method to action",
          "3. In Control Core: Settings â†’ Integrations â†’ Add API Gateway",
          "4. Configure field mappings for 4 attributes",
          "5. Test attribute retrieval with sample user/resource",
          "6. Enable caching (recommended: 5-15 minutes for user attributes)"
        ],
        "example_response": "Example API response will contain: GETâ†’read, POSTâ†’create, DELETEâ†’delete, GETâ†’read, POSTâ†’create, DELETEâ†’delete, GETâ†’read, POSTâ†’create, DELETEâ†’delete"
      },
      {
        "system": "Custom data source",
        "attributes_needed": [
          "input.context.currency",
          "input.context.customer_kyc_status",
          "input.context.customer_type",
          "input.resource.type",
          "input.context.customer_risk_level"
        ],
        "integration_steps": [
          "1. Obtain API credentials for Custom data source",
          "2. Test API access: REST API endpoint",
          "3. In Control Core: Settings â†’ Integrations â†’ Add Custom data source",
          "4. Configure field mappings for 5 attributes",
          "5. Test attribute retrieval with sample user/resource",
          "6. Enable caching (recommended: 5-15 minutes for user attributes)"
        ],
        "example_response": "Example API response will contain: context.currency, context.customer_kyc_status, context.customer_type"
      }
    ]
  }
}