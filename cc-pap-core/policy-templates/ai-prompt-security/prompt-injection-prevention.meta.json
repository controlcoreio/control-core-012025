{
  "version": "1.0.0",
  "summary": "Prompt Injection Prevention Policy Protects against prompt injection attacks on AI systems Default allow with security checks",
  "detailed_description": "This policy template implements Prompt Injection Prevention controls for Ai Prompt Security. It provides comprehensive authorization and governance capabilities with real-time policy evaluation. \n\nThe policy evaluates 14 different conditions including user attributes, resource properties, and contextual information. Policy decisions are made dynamically based on the current state of the system, user context, and resource characteristics. \n\nKey capabilities:\n- Real-time authorization decisions with sub-millisecond evaluation\n- Comprehensive audit logging for all policy evaluations\n- Dynamic context enrichment from multiple data sources\n- Fine-grained attribute-based access control (ABAC)\n- Support for both allow and deny rules with conflict resolution\n\n\nThis template is designed to be deployed in Control Core's policy engine and can be customized to meet your specific requirements. It follows best practices for policy authoring and includes comprehensive error handling.",
  "use_cases": [
    {
      "title": "Financial Services: AI-Powered Fraud Detection System",
      "description": "Deploy prompt-injection-prevention.meta for a production fraud detection AI model",
      "scenario": "Global Bank deploys an AI fraud detection model processing 10M daily transactions. Auditor requirement: demonstrate model approval process, training data governance, and bias testing before production deployment. Policy enforces: (1) Risk assessment by Chief AI Officer, (2) Validation by independent team showing <2% false positive rate, (3) Monthly bias audits on protected classes, (4) Automated rollback if accuracy drops below 95%. Compliance: Federal Reserve SR 11-7 (Model Risk Management)."
    },
    {
      "title": "Healthcare: Clinical Decision Support AI with HIPAA Requirements",
      "description": "Apply prompt-injection-prevention.meta to protect patient data in AI diagnostic systems",
      "scenario": "Hospital network implements AI radiology assistant analyzing 5,000 X-rays daily. Auditor verification needed: (1) All 47 radiologists have signed AI use agreements, (2) System logs every AI recommendation with radiologist override capability, (3) PHI access restricted to treating physicians only, (4) AI outputs reviewed by second physician for high-stakes diagnoses. Policy blocks: AI access outside treating relationship, automated AI decisions without physician review. HIPAA audit trail maintained for 6 years."
    },
    {
      "title": "Retail: Customer Service AI with PII Protection",
      "description": "Implement prompt-injection-prevention.meta for AI chatbot handling customer data",
      "scenario": "E-commerce platform's AI chatbot handles 50,000 daily customer interactions across EU and California. Compliance requirement: Demonstrate GDPR Article 22 (right to object to automated decisions) and CCPA compliance. Policy enforces: (1) Customer PII (SSN, payment details) masked in AI training data, (2) Chatbot unable to make purchase decisions >$500 without human, (3) EU customers can request human agent immediately, (4) All AI interactions logged with 'automated decision' flag. Reduced compliance violations from 12/month to zero."
    },
    {
      "title": "Insurance: Automated Underwriting with Fairness Requirements",
      "description": "Use prompt-injection-prevention.meta to ensure fair AI-driven insurance decisions",
      "scenario": "Insurance carrier uses AI to evaluate 15,000 policy applications monthly. State regulator audit focuses on: (1) Proving AI doesn't discriminate on race, gender (protected classes), (2) Demonstrating explainability for all denials, (3) Human review for borderline cases. Policy requires: Bias testing quarterly across 50+ demographic segments, explainability scores >0.7, senior underwriter review when AI confidence <85%. Result: Zero discrimination findings in regulatory exam, 23% faster application processing."
    },
    {
      "title": "Manufacturing: Predictive Maintenance AI with Safety Controls",
      "description": "Deploy prompt-injection-prevention.meta for safety-critical industrial AI systems",
      "scenario": "Auto manufacturer uses AI to predict equipment failures affecting 1,200 assembly robots. Safety audit requirements: (1) Prove AI trained only on verified sensor data, (2) Human override always available, (3) False negatives (missed failures) tracked and investigated, (4) AI recommendations reviewed by maintenance engineers before critical shutdowns. Policy enforces: 2-person approval for shutdowns affecting >50 workers, AI confidence thresholds before automated actions, incident tracking for all prediction failures."
    },
    {
      "title": "Government: AI in Public Services with Transparency Requirements",
      "description": "Apply prompt-injection-prevention.meta for government AI systems requiring public accountability",
      "scenario": "City government deploys AI for permit application processing (5,000/month). Public accountability requirements: (1) AI decision criteria published publicly, (2) Citizens can request human review within 5 business days, (3) Bias audits by independent third party annually, (4) Algorithmic Impact Assessment published. Policy ensures: All denials include explanation in plain language, applicant notification of AI use, appeals tracked with resolution times, bias metrics published quarterly."
    }
  ],
  "conditions": [
    {
      "name": "prompt.contains_sensitive_data",
      "type": "string",
      "description": "The 'prompt.contains_sensitive_data' attribute is evaluated at runtime to make policy decisions. This condition is checked against incoming request data to determine authorization.",
      "required": true,
      "data_sources": [
        {
          "name": "REST API Endpoints",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Policy Information Point (PIP)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Database Queries",
          "integration_method": "Direct SQL query - Control Core connects to application database to check resource ownership, classification tags",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'prompt.contains_sensitive_data' at policy evaluation time. This attribute will be included in the authorization request context. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'prompt.contains_sensitive_data' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'prompt.contains_sensitive_data':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'prompt.contains_sensitive_data' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [
        "value1",
        "value2",
        "value3"
      ],
      "example_value": "example_value"
    },
    {
      "name": "prompt.contains_system_commands",
      "type": "string",
      "description": "The 'prompt.contains_system_commands' attribute is evaluated at runtime to make policy decisions. This condition is checked against incoming request data to determine authorization.",
      "required": true,
      "data_sources": [
        {
          "name": "REST API Endpoints",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Policy Information Point (PIP)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Database Queries",
          "integration_method": "Direct SQL query - Control Core connects to application database to check resource ownership, classification tags",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'prompt.contains_system_commands' at policy evaluation time. This attribute will be included in the authorization request context. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'prompt.contains_system_commands' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'prompt.contains_system_commands':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'prompt.contains_system_commands' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [
        "value1",
        "value2",
        "value3"
      ],
      "example_value": "example_value"
    },
    {
      "name": "prompt.contains_user_input",
      "type": "object",
      "description": "The 'prompt.contains_user_input' attribute is evaluated at runtime to make policy decisions. This condition is checked against incoming request data to determine authorization.",
      "required": true,
      "data_sources": [
        {
          "name": "Identity Provider (IdP) - Okta, Auth0, Azure AD, etc.",
          "integration_method": "SAML or OIDC integration - Control Core retrieves user attributes from IdP token claims during authentication",
          "example_api": "GET /api/v1/users/{userId} returns {profile: {role: 'Manager', department: 'Finance'}}"
        },
        {
          "name": "JWT Token Claims",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "User Directory - LDAP, Active Directory",
          "integration_method": "LDAP query - Control Core queries AD for user groups, department, manager attributes in real-time",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'prompt.contains_user_input' at policy evaluation time. This attribute will be included in the authorization request context. Ensure your Identity Provider is properly integrated with Control Core. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'prompt.contains_user_input' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'prompt.contains_user_input':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'prompt.contains_user_input' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [],
      "example_value": "{\"id\": \"user123\", \"name\": \"John Doe\", \"email\": \"john.doe@example.com\"}"
    },
    {
      "name": "prompt.context_isolated",
      "type": "object",
      "description": "The 'prompt.context_isolated' attribute is evaluated at runtime to make policy decisions. This condition is checked against incoming request data to determine authorization.",
      "required": true,
      "data_sources": [
        {
          "name": "Event Streaming Platforms (Kafka, Kinesis)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "External APIs and Data Sources",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Real-time Data Pipelines",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'prompt.context_isolated' at policy evaluation time. This attribute will be included in the authorization request context. Set up a Context Generation Service to provide real-time context data. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'prompt.context_isolated' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'prompt.context_isolated':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'prompt.context_isolated' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [],
      "example_value": "{\"attribute\": \"value\", \"verified\": true}"
    },
    {
      "name": "prompt.context_manipulation",
      "type": "object",
      "description": "The 'prompt.context_manipulation' attribute is evaluated at runtime to make policy decisions. This condition is checked against incoming request data to determine authorization.",
      "required": true,
      "data_sources": [
        {
          "name": "Event Streaming Platforms (Kafka, Kinesis)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "VPN/Proxy Detection Services",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "GeoIP Databases",
          "integration_method": "Direct SQL query - Control Core connects to application database to check resource ownership, classification tags",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'prompt.context_manipulation' at policy evaluation time. This attribute will be included in the authorization request context. Set up a Context Generation Service to provide real-time context data. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'prompt.context_manipulation' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'prompt.context_manipulation':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'prompt.context_manipulation' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [],
      "example_value": "{\"attribute\": \"value\", \"verified\": true}"
    },
    {
      "name": "prompt.data_extraction_attempt",
      "type": "string",
      "description": "The 'prompt.data_extraction_attempt' attribute is evaluated at runtime to make policy decisions. This condition is checked against incoming request data to determine authorization.",
      "required": true,
      "data_sources": [
        {
          "name": "REST API Endpoints",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Policy Information Point (PIP)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Database Queries",
          "integration_method": "Direct SQL query - Control Core connects to application database to check resource ownership, classification tags",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'prompt.data_extraction_attempt' at policy evaluation time. This attribute will be included in the authorization request context. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'prompt.data_extraction_attempt' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'prompt.data_extraction_attempt':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'prompt.data_extraction_attempt' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [
        "value1",
        "value2",
        "value3"
      ],
      "example_value": "read"
    },
    {
      "name": "prompt.injection_patterns",
      "type": "string",
      "description": "The 'prompt.injection_patterns' attribute is evaluated at runtime to make policy decisions. This condition is checked against incoming request data to determine authorization.",
      "required": true,
      "data_sources": [
        {
          "name": "REST API Endpoints",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Policy Information Point (PIP)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Database Queries",
          "integration_method": "Direct SQL query - Control Core connects to application database to check resource ownership, classification tags",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'prompt.injection_patterns' at policy evaluation time. This attribute will be included in the authorization request context. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'prompt.injection_patterns' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'prompt.injection_patterns':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'prompt.injection_patterns' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [
        "value1",
        "value2",
        "value3"
      ],
      "example_value": "example_value"
    },
    {
      "name": "prompt.length",
      "type": "string",
      "description": "The 'prompt.length' attribute is evaluated at runtime to make policy decisions. This condition is checked against incoming request data to determine authorization.",
      "required": true,
      "data_sources": [
        {
          "name": "REST API Endpoints",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Policy Information Point (PIP)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Database Queries",
          "integration_method": "Direct SQL query - Control Core connects to application database to check resource ownership, classification tags",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'prompt.length' at policy evaluation time. This attribute will be included in the authorization request context. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'prompt.length' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'prompt.length':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'prompt.length' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [
        "value1",
        "value2",
        "value3"
      ],
      "example_value": "example_value"
    },
    {
      "name": "prompt.role_manipulation",
      "type": "string",
      "description": "The 'prompt.role_manipulation' attribute is evaluated at runtime to make policy decisions. This condition is checked against incoming request data to determine authorization.",
      "required": true,
      "data_sources": [
        {
          "name": "Role-Based Access Control (RBAC) System",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Identity Provider Role Assignments",
          "integration_method": "SAML or OIDC integration - Control Core retrieves user attributes from IdP token claims during authentication",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "VPN/Proxy Detection Services",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'prompt.role_manipulation' at policy evaluation time. This attribute will be included in the authorization request context. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'prompt.role_manipulation' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'prompt.role_manipulation':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'prompt.role_manipulation' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [
        "value1",
        "value2",
        "value3"
      ],
      "example_value": "user"
    },
    {
      "name": "prompt.sanitized",
      "type": "string",
      "description": "The 'prompt.sanitized' attribute is evaluated at runtime to make policy decisions. This condition is checked against incoming request data to determine authorization.",
      "required": true,
      "data_sources": [
        {
          "name": "REST API Endpoints",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Policy Information Point (PIP)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Database Queries",
          "integration_method": "Direct SQL query - Control Core connects to application database to check resource ownership, classification tags",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'prompt.sanitized' at policy evaluation time. This attribute will be included in the authorization request context. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'prompt.sanitized' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'prompt.sanitized':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'prompt.sanitized' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [
        "value1",
        "value2",
        "value3"
      ],
      "example_value": "example_value"
    },
    {
      "name": "prompt.suspicious_patterns",
      "type": "string",
      "description": "The 'prompt.suspicious_patterns' attribute is evaluated at runtime to make policy decisions. This condition is checked against incoming request data to determine authorization.",
      "required": true,
      "data_sources": [
        {
          "name": "REST API Endpoints",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Policy Information Point (PIP)",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Database Queries",
          "integration_method": "Direct SQL query - Control Core connects to application database to check resource ownership, classification tags",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'prompt.suspicious_patterns' at policy evaluation time. This attribute will be included in the authorization request context. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'prompt.suspicious_patterns' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'prompt.suspicious_patterns':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'prompt.suspicious_patterns' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [
        "value1",
        "value2",
        "value3"
      ],
      "example_value": "example_value"
    },
    {
      "name": "prompt.validated",
      "type": "string",
      "description": "The 'prompt.validated' attribute is evaluated at runtime to make policy decisions. This condition is checked against incoming request data to determine authorization.",
      "required": true,
      "data_sources": [
        {
          "name": "System Clock / NTP Servers",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'prompt.validated' at policy evaluation time. This attribute will be included in the authorization request context. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'prompt.validated' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'prompt.validated':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'prompt.validated' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [
        "value1",
        "value2",
        "value3"
      ],
      "example_value": "2024-10-23T14:30:00Z"
    },
    {
      "name": "user.rate_limit_exceeded",
      "type": "integer",
      "description": "User attribute 'rate_limit_exceeded' - identifies or describes the user making the request. This is evaluated at runtime to determine if the user meets the required criteria.",
      "required": true,
      "data_sources": [
        {
          "name": "Identity Provider (IdP) - Okta, Auth0, Azure AD, etc.",
          "integration_method": "SAML or OIDC integration - Control Core retrieves user attributes from IdP token claims during authentication",
          "example_api": "GET /api/v1/users/{userId} returns {profile: {role: 'Manager', department: 'Finance'}}"
        },
        {
          "name": "JWT Token Claims",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "User Directory - LDAP, Active Directory",
          "integration_method": "LDAP query - Control Core queries AD for user groups, department, manager attributes in real-time",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'user.rate_limit_exceeded' at policy evaluation time. This attribute will be included in the authorization request context. Ensure your Identity Provider is properly integrated with Control Core. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "Runtime evaluation of 'user.rate_limit_exceeded' to make access control decisions based on current request context.",
      "how_to_fetch": "Configure Control Core to fetch 'user.rate_limit_exceeded':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'user.rate_limit_exceeded' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [],
      "example_value": "10"
    },
    {
      "name": "user.role",
      "type": "object",
      "description": "User attribute 'role' - identifies or describes the user making the request. This is evaluated at runtime to determine if the user meets the required criteria.",
      "required": true,
      "data_sources": [
        {
          "name": "Identity Provider (IdP) - Okta, Auth0, Azure AD, etc.",
          "integration_method": "SAML or OIDC integration - Control Core retrieves user attributes from IdP token claims during authentication",
          "example_api": "GET /api/v1/users/{userId} returns {profile: {role: 'Manager', department: 'Finance'}}"
        },
        {
          "name": "JWT Token Claims",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        },
        {
          "name": "Role-Based Access Control (RBAC) System",
          "integration_method": "API integration - Control Core fetches this attribute via REST API call during policy evaluation",
          "example_api": "Example: GET /api/attributes/{attributeName}?userId={userId}"
        }
      ],
      "configuration_notes": "Configure Control Core to fetch 'user.role' at policy evaluation time. This attribute will be included in the authorization request context. Ensure your Identity Provider is properly integrated with Control Core. Map this attribute in your Policy Enforcement Point (PEP) configuration.",
      "plain_english": "The job role or function of the person making the request (e.g., 'Manager', 'Analyst', 'Admin'). Used to enforce role-based access controls ensuring users only access data appropriate for their job function.",
      "how_to_fetch": "Configure Control Core to fetch 'user.role':\n1. In Control Core Admin UI, go to Settings > Attribute Sources\n2. Click 'Add Attribute Source' and select your identity/data provider\n3. Map 'user.role' to the corresponding field in your source system\n4. Configure refresh interval (e.g., cache for 5 minutes, fetch on each request for sensitive data)\n5. Test the mapping with sample users to verify correct values are retrieved\n6. Enable the attribute for use in policies",
      "example_values": [
        "Manager",
        "Senior Analyst",
        "Junior Developer",
        "Executive",
        "Contractor"
      ],
      "example_value": "{\"roles\": [\"user\", \"editor\"], \"primary_role\": \"user\"}"
    }
  ],
  "requirements": {
    "detailed_requirements": {
      "identity_and_access": [
        {
          "condition": "input.user.rate_limit_exceeded",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "user.rate_limit_exceeded",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.user.role",
          "system": "Okta",
          "api_endpoint": "GET /api/v1/users/{userId}/roles",
          "field_mapping": "type",
          "integration_method": "REST API",
          "setup_notes": "Configure custom user attributes in Okta profile",
          "documentation": ""
        },
        {
          "condition": "input.user.role",
          "system": "Azure AD",
          "api_endpoint": "GET /v1.0/users/{userId}/appRoleAssignments",
          "field_mapping": "appRoleId",
          "integration_method": "REST API",
          "setup_notes": "Define app roles in Azure AD app registration",
          "documentation": ""
        },
        {
          "condition": "input.user.role",
          "system": "Auth0",
          "api_endpoint": "GET /api/v2/users/{userId}/roles",
          "field_mapping": "name",
          "integration_method": "REST API",
          "setup_notes": "Create roles in Auth0 dashboard",
          "documentation": ""
        },
        {
          "condition": "input.user.role",
          "system": "Custom RBAC Database",
          "api_endpoint": "SELECT role FROM user_roles WHERE user_id = ?",
          "field_mapping": "role",
          "integration_method": "REST API",
          "setup_notes": "Expose REST API endpoint for role lookup",
          "documentation": ""
        }
      ],
      "data_sources": [
        {
          "condition": "input.prompt.contains_sensitive_data",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "prompt.contains_sensitive_data",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.prompt.contains_system_commands",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "prompt.contains_system_commands",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.prompt.contains_user_input",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "prompt.contains_user_input",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.prompt.context_isolated",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "prompt.context_isolated",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.prompt.context_manipulation",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "prompt.context_manipulation",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.prompt.data_extraction_attempt",
          "system": "Application Code",
          "api_endpoint": "Application sends action in request",
          "field_mapping": "action",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.prompt.data_extraction_attempt",
          "system": "API Gateway",
          "api_endpoint": "Map HTTP method to action",
          "field_mapping": "GET→read, POST→create, DELETE→delete",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.prompt.injection_patterns",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "prompt.injection_patterns",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.prompt.length",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "prompt.length",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.prompt.role_manipulation",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "prompt.role_manipulation",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.prompt.sanitized",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "prompt.sanitized",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.prompt.suspicious_patterns",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "prompt.suspicious_patterns",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        },
        {
          "condition": "input.prompt.validated",
          "system": "Custom data source",
          "api_endpoint": "REST API endpoint",
          "field_mapping": "prompt.validated",
          "integration_method": "REST API",
          "setup_notes": "Configure in system admin",
          "documentation": ""
        }
      ]
    },
    "systems_needed": [
      "API Gateway",
      "Application Code",
      "Auth0",
      "Azure AD",
      "Custom RBAC Database",
      "Custom data source",
      "Okta"
    ],
    "complexity_score": "High - Complex policy with many conditions and data sources"
  },
  "deployment_notes": {
    "setup_steps": [
      "1. Review policy requirements and ensure all prerequisites are met",
      "2. Configure data sources and integrations in Control Core",
      "3. Map required attributes (14 conditions identified) to your data sources",
      "4. Deploy policy to Sandbox environment using Control Core Admin UI",
      "5. Configure test users, resources, and scenarios in Sandbox",
      "6. Run comprehensive tests with various authorization scenarios",
      "7. Monitor policy evaluation logs and adjust conditions as needed",
      "8. Validate audit logging and compliance reporting",
      "9. Conduct user acceptance testing with stakeholders",
      "10. Promote to Production with gradual rollout (shadow mode, then enforcement)",
      "11. Set up monitoring alerts for policy violations and errors",
      "12. Document policy configuration and operational procedures"
    ],
    "sandbox_testing": [
      "🧪 Deploy to Sandbox environment first:",
      "   1. Create test users with various attribute combinations",
      "   2. Set up test resources with different classifications",
      "   3. Run test scenarios:",
      "      • User with all required attributes → ALLOW",
      "      • User missing required attribute → DENY",
      "      • User with insufficient privileges → DENY",
      "   4. Verify audit logs capture all evaluations",
      "   5. Check performance (policy evaluation < 100ms)",
      "   6. Test error handling (missing attributes, null values)"
    ],
    "configuration_tips": [
      "Start with permissive policies and gradually tighten restrictions",
      "Use policy versioning to track changes and enable rollbacks",
      "Implement comprehensive logging before enforcement",
      "Test in shadow mode to observe behavior without blocking access",
      "Document all customizations and environment-specific settings",
      "Set up monitoring dashboards for policy metrics",
      "Create runbooks for common policy-related incidents",
      "Establish a policy review and update schedule"
    ],
    "production_deployment": [
      "🚀 Production deployment checklist:",
      "   1. ✅ All sandbox tests passing",
      "   2. ✅ Stakeholder approval documented",
      "   3. ✅ Rollback plan prepared",
      "   4. ✅ Deploy in shadow mode (log only, don't enforce) for 24-48 hours",
      "   5. ✅ Review shadow mode logs for unexpected denials",
      "   6. ✅ Adjust policy based on real traffic patterns",
      "   7. ✅ Enable enforcement mode with gradual rollout (10% → 50% → 100%)",
      "   8. ✅ Monitor error rates and user feedback",
      "   9. ✅ Document deployment for compliance audit trail"
    ],
    "troubleshooting": [
      "Check Control Core logs if policy evaluation fails",
      "Verify all required attributes are available in request context",
      "Ensure data source integrations are healthy and responsive",
      "Review audit logs to understand policy decisions",
      "Use Control Core's policy testing tools to debug conditions",
      "Check for network connectivity issues between PEP and PDP",
      "Verify policy syntax and structure using validator",
      "Contact Control Core support for persistent issues"
    ],
    "prerequisites": [
      "✅ Inventory all systems needed for 14 conditions in this policy",
      "✅ Verify API access and credentials for each system",
      "✅ Test API endpoints return expected data format",
      "✅ Document field mappings between your systems and policy conditions",
      "✅ Ensure network connectivity from Control Core to all data sources"
    ],
    "data_source_configuration": [
      "\n📦 Identity And Access:",
      "   • Configure Custom data source integration for 'input.user.rate_limit_exceeded'",
      "     - API: REST API endpoint",
      "     - Field: user.rate_limit_exceeded",
      "     - Method: REST API",
      "   • Configure Okta integration for 'input.user.role'",
      "     - API: GET /api/v1/users/{userId}/roles",
      "     - Field: type",
      "     - Method: REST API",
      "   • Configure Azure AD integration for 'input.user.role'",
      "     - API: GET /v1.0/users/{userId}/appRoleAssignments",
      "     - Field: appRoleId",
      "     - Method: REST API",
      "\n📦 Data Sources:",
      "   • Configure Custom data source integration for 'input.prompt.contains_sensitive_data'",
      "     - API: REST API endpoint",
      "     - Field: prompt.contains_sensitive_data",
      "     - Method: REST API",
      "   • Configure Custom data source integration for 'input.prompt.contains_system_commands'",
      "     - API: REST API endpoint",
      "     - Field: prompt.contains_system_commands",
      "     - Method: REST API",
      "   • Configure Custom data source integration for 'input.prompt.contains_user_input'",
      "     - API: REST API endpoint",
      "     - Field: prompt.contains_user_input",
      "     - Method: REST API"
    ],
    "policy_customization": [
      "🔧 Review and customize the following conditions for your environment:",
      "   • User conditions (2): user.rate_limit_exceeded, user.role",
      "",
      "📝 Modification guidelines:",
      "   • Update attribute names to match your system's field names",
      "   • Adjust threshold values (e.g., risk scores, time windows)",
      "   • Add/remove conditions based on your requirements",
      "   • Test each condition individually before combining",
      "",
      "💾 Save modified policy with version tag for tracking"
    ],
    "monitoring_setup": [
      "📊 Set up monitoring and alerts:",
      "   • Policy evaluation count (baseline: track for 1 week)",
      "   • Denial rate (alert if > 5% of requests)",
      "   • Evaluation latency (alert if > 200ms p95)",
      "   • Missing attribute errors (alert on any occurrence)",
      "   • Condition-specific metrics:",
      "     1. Monitor 'input.prompt.contains_sensitive_data' - track null/missing values",
      "     2. Monitor 'input.prompt.contains_system_commands' - track null/missing values",
      "     3. Monitor 'input.prompt.contains_user_input' - track null/missing values",
      "     4. Monitor 'input.prompt.context_isolated' - track null/missing values",
      "     5. Monitor 'input.prompt.context_manipulation' - track null/missing values"
    ]
  },
  "compliance_frameworks": [
    "ISO 27001",
    "SOC 2 Type II"
  ],
  "risk_level": "critical",
  "tags": [
    "prevention",
    "prompt",
    "injection",
    "audit-logging",
    "rbac",
    "ai-prompt-security"
  ],
  "related_templates": [
    "ai-model-monitoring-drift-detection",
    "ai-agent-authorization",
    "ai-bias-detection-mitigation"
  ],
  "conditions_analysis": {
    "total_conditions": 14,
    "user_attributes": 2,
    "resource_attributes": 0,
    "context_attributes": 0
  },
  "integration_guide": {
    "overview": "This guide helps you integrate Control Core with your technical stack to fetch the required attributes.",
    "steps_by_system": [
      {
        "system": "Custom data source",
        "attributes_needed": [
          "input.user.rate_limit_exceeded",
          "input.prompt.contains_sensitive_data",
          "input.prompt.contains_system_commands",
          "input.prompt.contains_user_input",
          "input.prompt.context_isolated",
          "input.prompt.context_manipulation",
          "input.prompt.injection_patterns",
          "input.prompt.length",
          "input.prompt.role_manipulation",
          "input.prompt.sanitized",
          "input.prompt.suspicious_patterns",
          "input.prompt.validated"
        ],
        "integration_steps": [
          "1. Obtain API credentials for Custom data source",
          "2. Test API access: REST API endpoint",
          "3. In Control Core: Settings → Integrations → Add Custom data source",
          "4. Configure field mappings for 12 attributes",
          "5. Test attribute retrieval with sample user/resource",
          "6. Enable caching (recommended: 5-15 minutes for user attributes)"
        ],
        "example_response": "Example API response will contain: user.rate_limit_exceeded, prompt.contains_sensitive_data, prompt.contains_system_commands"
      },
      {
        "system": "Okta",
        "attributes_needed": [
          "input.user.role"
        ],
        "integration_steps": [
          "1. Obtain API credentials for Okta",
          "2. Test API access: GET /api/v1/users/{userId}/roles",
          "3. In Control Core: Settings → Integrations → Add Okta",
          "4. Configure field mappings for 1 attributes",
          "5. Test attribute retrieval with sample user/resource",
          "6. Enable caching (recommended: 5-15 minutes for user attributes)"
        ],
        "example_response": "Example API response will contain: type"
      },
      {
        "system": "Azure AD",
        "attributes_needed": [
          "input.user.role"
        ],
        "integration_steps": [
          "1. Obtain API credentials for Azure AD",
          "2. Test API access: GET /v1.0/users/{userId}/appRoleAssignments",
          "3. In Control Core: Settings → Integrations → Add Azure AD",
          "4. Configure field mappings for 1 attributes",
          "5. Test attribute retrieval with sample user/resource",
          "6. Enable caching (recommended: 5-15 minutes for user attributes)"
        ],
        "example_response": "Example API response will contain: appRoleId"
      },
      {
        "system": "Auth0",
        "attributes_needed": [
          "input.user.role"
        ],
        "integration_steps": [
          "1. Obtain API credentials for Auth0",
          "2. Test API access: GET /api/v2/users/{userId}/roles",
          "3. In Control Core: Settings → Integrations → Add Auth0",
          "4. Configure field mappings for 1 attributes",
          "5. Test attribute retrieval with sample user/resource",
          "6. Enable caching (recommended: 5-15 minutes for user attributes)"
        ],
        "example_response": "Example API response will contain: name"
      },
      {
        "system": "Custom RBAC Database",
        "attributes_needed": [
          "input.user.role"
        ],
        "integration_steps": [
          "1. Obtain API credentials for Custom RBAC Database",
          "2. Test API access: SELECT role FROM user_roles WHERE user_id = ?",
          "3. In Control Core: Settings → Integrations → Add Custom RBAC Database",
          "4. Configure field mappings for 1 attributes",
          "5. Test attribute retrieval with sample user/resource",
          "6. Enable caching (recommended: 5-15 minutes for user attributes)"
        ],
        "example_response": "Example API response will contain: role"
      }
    ]
  }
}